<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Async 库之 parallel 源码分析]]></title>
    <url>%2FNodejs%2Fasync-parallel%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前面做过 series 的源码分析后，大体知道了其内部原理。现在来看看 parallel 实现。首先贴出重要代码部分（该case基于Async 2.6.2 做的分析）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253exports.parallel = parallelLimit;function parallelLimit(tasks, callback) &#123; _parallel(eachOf, tasks, callback);&#125;// 与 series 调用同一个方法function _parallel(eachfn, tasks, callback) &#123; callback = callback || noop; var results = isArrayLike(tasks) ? [] : &#123;&#125;; eachfn(tasks, function (task, key, callback) &#123; wrapAsync(task)(function (err, result) &#123; if (arguments.length &gt; 2) &#123; result = slice(arguments, 1); &#125; results[key] = result; callback(err); &#125;); &#125;, function (err) &#123; callback(err, results); &#125;);&#125;var eachOf = function(coll, iteratee, callback) &#123; // 根据任务的不同返回不同实现，在 series 文章中分析过 isArrayLike var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric; eachOfImplementation(coll, wrapAsync(iteratee), callback);&#125;;// eachOf implementation optimized for array-likesfunction eachOfArrayLike(coll, iteratee, callback) &#123; callback = once(callback || noop); var index = 0, completed = 0, length = coll.length; if (length === 0) &#123; callback(null); &#125; function iteratorCallback(err, value) &#123; if (err) &#123; callback(err); &#125; else if ((++completed === length) || value === breakLoop) &#123; callback(null); &#125; &#125; for (; index &lt; length; index++) &#123; iteratee(coll[index], index, onlyOnce(iteratorCallback)); &#125;&#125;var eachOfGeneric = doLimit(eachOfLimit, Infinity); 这里涉及到两个实现： eachOfArrayLike eachOfGeneric 1. &emsp; eachOfGeneric &emsp;&emsp; 先来分析使用 eachOfGeneric 的情况，实际 eachOfGeneric 就是 doLimit。只不过与 series 方法对比的话，这里的 limit 参数是一个无穷大的数（即当前执行任务的数量没有上限），而 series 的 limit 参数是 1，因为 series 需要保证顺序执行。 还是回到具体实现的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function _eachOfLimit(limit) &#123; return function (obj, iteratee, callback) &#123; callback = once(callback || noop); if (limit &lt;= 0 || !obj) &#123; return callback(null); &#125; var nextElem = iterator(obj); var done = false; var running = 0; // 记录当前正在执行的任务数 var looping = false; function iterateeCallback(err, value) &#123; running -= 1; // 每执行完成一个任务就减一 if (err) &#123; // 出错则返回 done = true; callback(err); &#125; // 这里分两种情况： // 1. 跳出循环，即 value = &#123;&#125; // 2. 所有任务已全部执行完成，正是这里确保了所有任务执行完成后统一返回执行结果 else if (value === breakLoop || (done &amp;&amp; running &lt;= 0)) &#123; done = true; return callback(null); &#125; else if (!looping) &#123; // 此处不会响应，因为在 replenish 中会不断的执行任务，直到没有任务 // 也就是 elem = null 时就已经 return 返回，也就不会执行 looping = false replenish(); &#125; &#125; function replenish () &#123; looping = true; while (running &lt; limit &amp;&amp; !done) &#123; // 还有未执行的任务 并且 当前执行的任务数小于上限，limit = Infinity var elem = nextElem(); if (elem === null) &#123; done = true; // 任务已全部执行，等待所有任务完成 if (running &lt;= 0) &#123; // 若任务已全部执行完成则返回 callback(null); &#125; return; &#125; running += 1; // 每执行一个任务就加一 iteratee(elem.value, elem.key, onlyOnce(iterateeCallback)); &#125; looping = false; &#125; replenish(); &#125;;&#125; 该代码可以用这个入参做测试：1234567891011121314151617181920212223const list = &#123; items:[ async function(callback) &#123; //此处callback无效 var result = await test(); return result; // callback(null,result); &#125;,function(callback)&#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;, function(callback)&#123; setTimeout(function() &#123; callback(null, 12); &#125;, 10000); &#125; ], *[Symbol.iterator]()&#123; for(let item of this.items)&#123; yield item; &#125; &#125;&#125;; 2. &emsp; eachOfArrayLike 下面来看看 eachOfArrayLike 的实现：12345678910111213141516171819202122// eachOf implementation optimized for array-likesfunction eachOfArrayLike(coll, iteratee, callback) &#123; callback = once(callback || noop); var index = 0, completed = 0, length = coll.length; if (length === 0) &#123; callback(null); &#125; function iteratorCallback(err, value) &#123; if (err) &#123; callback(err); &#125; else if ((++completed === length) || value === breakLoop) &#123; callback(null); &#125; &#125; for (; index &lt; length; index++) &#123; iteratee(coll[index], index, onlyOnce(iteratorCallback)); &#125;&#125; 入参可以随便创建一个任务数组即可： 1234567891011121314151617var ar = [ async function(callback) &#123; //此处callback无效 var result = await test(); return result; // callback(null,result); &#125;, function(callback)&#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;, function(callback)&#123; setTimeout(function() &#123; callback(null, 12); &#125;, 10000); &#125;]; 这里不太明白为什么还要做 isArrayLike 区分，因为在 doLimit中已经做了区分。我将源码改为统一的 eachOfGeneric实现，然后使用任务数组做入参，结果并没有什么不同。]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Async 库之 series 源码分析]]></title>
    <url>%2FNodejs%2Fasync-series%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;学习过Nodejs的同学应该少不了会遇到Async库，其中的series方法应该有人用过，好奇心作怪就做了一个测试案例来分析下内部实现。先上测试代码，其中包括同步任务及异步任务（该case基于Async 2.6.2 做的分析）： 1234567891011121314151617181920212223242526var async = require('async');var test = function()&#123; return new Promise(function(resovle,reject)&#123; setTimeout(function() &#123; resovle(1); &#125;, 200); &#125;);&#125;async.series(&#123; one: async function(callback) &#123; //此处callback无效 var result = await test(); return result; // callback(null,result); &#125;, two: function(callback)&#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;&#125;, function(err, results) &#123; // results is now equal to: &#123;one: 1, two: 2&#125; console.log(results);&#125;); 点击series进入到源码，看到series方法调用的是 _parallel 方法，之后调用了很多高阶函数，容易晕。先把重要代码贴上： 12345678910111213141516171819202122232425262728293031var eachOfSeries = doLimit(eachOfLimit, 1); function series(tasks, callback) &#123; _parallel(eachOfSeries, tasks, callback);&#125;function _parallel(eachfn, tasks, callback) &#123; callback = callback || noop; var results = isArrayLike(tasks) ? [] : &#123;&#125;; eachfn(tasks, function (task, key, callback) &#123; wrapAsync(task)(function (err, result) &#123; if (arguments.length &gt; 2) &#123; result = slice(arguments, 1); &#125; results[key] = result; callback(err); &#125;); &#125;, function (err) &#123; callback(err, results); &#125;);&#125;function doLimit(fn, limit) &#123; return function (iterable, iteratee, callback) &#123; return fn(iterable, limit, iteratee, callback); &#125;;&#125;function eachOfLimit(coll, limit, iteratee, callback) &#123; _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);&#125; 首先分析主函数 _parallel，该方法主要部分是 eachfn，而eachfn实际上是 doLimit，再进入到 doLimit 后发现，实际就变成了执行 _eachOfLimit 内部函数，最终看到了执行的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function _eachOfLimit(limit) &#123; return function (obj, iteratee, callback) &#123; callback = once(callback || noop); if (limit &lt;= 0 || !obj) &#123; return callback(null); &#125; var nextElem = iterator(obj); var done = false; var running = 0; // 记录当前正在执行的任务数 var looping = false; // 标记任务在进入异步队列前的同步过程，执行中或结束 function iterateeCallback(err, value) &#123; running -= 1; // 每执行完成一个任务就减一 if (err) &#123; // 出错则返回 done = true; callback(err); &#125; // 这里分两种情况： // 1. 跳出循环，即 value = &#123;&#125; // 2. 所有任务已全部执行完成 else if (value === breakLoop || (done &amp;&amp; running &lt;= 0)) &#123; done = true; return callback(null); &#125; else if (!looping) &#123; replenish(); &#125; &#125; function replenish () &#123; looping = true; // 同步过程执行中 // 若仍有未执行的任务 并且 当前执行的任务数小于上限 limit = 1，即当前只有一个任务在执行 // 所以这里就确保了任务的顺序执行，执行完成后 looping = false，回调后继续调用 replenish 执行下一个任务 while (running &lt; limit &amp;&amp; !done) &#123; var elem = nextElem(); if (elem === null) &#123; done = true; // 任务已全部执行，等待所有任务完成 if (running &lt;= 0) &#123; // 若任务已全部执行完成则返回 callback(null); &#125; return; &#125; running += 1; // 每执行一个任务就加一 iteratee(elem.value, elem.key, onlyOnce(iterateeCallback)); &#125; looping = false; // 同步过程已结束，等异步通知 iterateeCallback &#125; replenish(); &#125;;&#125; 通过代码可以知道该方法是通过设置当前执行函数的个数来保证任务的顺序执行，即 limit=1。待前一个任务执行完成并通过callback返回后才执行下一个函数。该方法使用了一个running变量来标记当前正在执行的任务，每执行一个就加一，待回调完成后减一。 该方法的执行过程会涉及到几个问题： 任务会分为同步任务及异步任务，如何保证他们正确顺序执行？ 假如series的任务参数是es6中迭代器对象，如何任务正确迭代遍历？ 1 任务会分为同步任务及异步任务，如何保证他们正确顺序执行？ &emsp;&emsp;同步任务很好理解，函数执行完成后直接调用callback函数即可返回，然后继续执行下一个任务。但是异步任务就有可能是一个Promise或者加了async关键字的函数.这时就需要判断一个函数是否是异步函数。单单判断函数异步是异步函数还不行，因为异步函数不会自动执行，所以还要异步函数可以自动执行然后顺利回调callback。&emsp;&emsp; 1.1 &emsp;判断异步函数 &emsp;&emsp;查看源码可以看到： 12345var supportsSymbol = typeof Symbol === 'function';function isAsync(fn) &#123; return supportsSymbol &amp;&amp; fn[Symbol.toStringTag] === 'AsyncFunction';&#125; &emsp;&emsp;ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。Symbol 值通过 Symbol 函数 生成。因为需要用到Symbol做判断，所以首先判断是否支持该原始类型。 &emsp;&emsp;对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型. 123456789101112// 例一(&#123;[Symbol.toStringTag]: 'Foo'&#125;.toString())// "[object Foo]"// 例二class Collection &#123; get [Symbol.toStringTag]() &#123; return 'xxx'; &#125;&#125;let x = new Collection();Object.prototype.toString.call(x) // "[object xxx]" 通过阮大师的es了解到了以上情况，但是fn[Symbol.toStringTag] 为什么会是 ‘AsyncFunction’这个没理解。估计在内部做了封装。判断是否是异步函数还可以通过以下方式来判断（generator函数同理）。123const AsyncFunction = (async () =&gt; &#123;&#125;).constructor;asyncFn instanceof AsyncFunction // true &emsp;&emsp; 1.2 &emsp;执行异步函数 &emsp;&emsp;通过以下代码可知，若当前函数是异步函数则将该函数做异步包装，通过func.apply(this, args)执行函数，若该函数返回的是一个Promise对象，则执行then函数获取执行结果，然后执行callback。12345678910111213141516171819202122232425262728293031323334353637function wrapAsync(asyncFn) &#123; return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;&#125;function asyncify(func) &#123; return initialParams(function (args, callback) &#123; var result; try &#123; result = func.apply(this, args); &#125; catch (e) &#123; return callback(e); &#125; // if result is Promise object if (isObject(result) &amp;&amp; typeof result.then === 'function') &#123; result.then(function(value) &#123; invokeCallback(callback, null, value); &#125;, function(err) &#123; invokeCallback(callback, err.message ? err : new Error(err)); &#125;); &#125; else &#123; callback(null, result); &#125; &#125;);&#125;var initialParams = function (fn) &#123; return function (/*...args, callback*/) &#123; var args = slice(arguments); var callback = args.pop(); fn.call(this, args, callback); &#125;;&#125;;function invokeCallback(callback, error, value) &#123; try &#123; callback(error, value); &#125; catch (e) &#123; setImmediate$1(rethrow, e); &#125;&#125; 执行callback时还加了一个try catch，若callback出现异常则通过异步的方式抛出该异常，可以看看这段代码。最先通过setImmediate方法抛出异常，若该方法没有则使用 process.nextTick ，若再没有则执行通过 setTimeout 方法抛出。123456789101112131415161718192021222324252627var hasSetImmediate = typeof setImmediate === 'function' &amp;&amp; setImmediate;var hasNextTick = typeof process === 'object' &amp;&amp; typeof process.nextTick === 'function';function fallback(fn) &#123; setTimeout(fn, 0);&#125;function wrap(defer) &#123; return function (fn/*, ...args*/) &#123; var args = slice(arguments, 1); defer(function () &#123; fn.apply(null, args); &#125;); &#125;;&#125;var _defer;if (hasSetImmediate) &#123; _defer = setImmediate;&#125; else if (hasNextTick) &#123; _defer = process.nextTick;&#125; else &#123; _defer = fallback;&#125;var setImmediate$1 = wrap(_defer); 看过Promise源码的应该可以知道Promise也是使用该方式来保证任务的异步执行，只是没有用到 setTimeout 方法。代码注释里说到为什么要首先使用setImmediate，是因为process.nextTick无法处理递归调用。对这块还不太理解，小伙伴们知道的麻烦告知一声。 2 假如series的任务参数是es6中迭代器对象，如何任务正确迭代遍历？&emsp;&emsp;在es6之前我们传入的参数可以是一个数组或者json对象，但在es6增加了一个生成器函数。生成器函数会返回一个迭代器对象。默认情况下定义的对象（object）是不可迭代的，但是可以通过Symbol.iterator创建迭代器。如：123456789101112const list = &#123; items:[5,9,18], *[Symbol.iterator]()&#123; for(let item of this.items)&#123; yield item; &#125; &#125;&#125;for(let item of list)&#123; console.log(item); //5,9,18&#125; 所以series的入参也就可以是一个可迭代的对象。测试代码修改如下：12345678910111213141516171819202122// 将我们的任务直接放到items数组中，items这个属性可以自行定义，只要保证正确遍历即可const list = &#123; items:[async function(callback) &#123; //此处callback无效 var result = await test(); return result; // callback(null,result); &#125;,function(callback)&#123; setTimeout(function() &#123; callback(null, 2); &#125;, 100); &#125;], *[Symbol.iterator]()&#123; for(let item of this.items)&#123; yield item; &#125; &#125;&#125;async.series(list, function(err, results) &#123; // results is now equal to: &#123;one: 1, two: 2&#125; console.log(results);&#125;); 代码分析到这里，应该就可以想到series的入参是需要判断的。该参数很有可能是一个迭代器对象。通过源码可以发下这里面做了判断： 12345678910// _eachOfLimit 方法中的( async 2.6.2 )：// var nextElem = iterator(obj); // line 979function iterator(coll) &#123; if (isArrayLike(coll)) &#123; return createArrayIterator(coll); &#125; var iterator = getIterator(coll); return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);&#125; 针对不同的入参就需要不同的遍历方式： 若是数组则通过下标进行遍历 若是生成器返回的迭代器对象则通过next()的方式进行遍历 若只是一个对象，则通过遍历其所有的key进行遍历 数组遍历的方式就不用说了，咱们来看看其他两种方式2.1 &emsp;通过生成器返回的迭代器进行遍历&emsp;&emsp;该迭代器是通过next()方法来获得当前对象，其中包含done（是否遍历完成），value（当前元素）。学过Java或C#应该容易理解，他们都有一个hasNext()及next()方法，hasNext()用于判断是否还有下一个元素，next()用于获取下一个元素。生成器generator是通过协程的方式实现，这个还需深入了解。12345678910function createES2015Iterator(iterator) &#123; var i = -1; return function next() &#123; var item = iterator.next(); if (item.done) return null; i++; return &#123;value: item.value, key: i&#125;; &#125; &#125; 2.2 &emsp;通过遍历所有的key进行遍历 123456789function createObjectIterator(obj) &#123; var okeys = keys(obj); var i = -1; var len = okeys.length; return function next() &#123; var key = okeys[++i]; return i &lt; len ? &#123;value: obj[key], key: key&#125; : null; &#125;; &#125; 该方式的重点在keys方法，该遍历方式远比我想象的要复杂些。123456789101112131415161718192021222324252627282930313233343536373839404142function keys(object) &#123; return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);&#125;function arrayLikeKeys(value, inherited) &#123; var isArr = isArray(value), isArg = !isArr &amp;&amp; isArguments(value), isBuff = !isArr &amp;&amp; !isArg &amp;&amp; isBuffer(value), isType = !isArr &amp;&amp; !isArg &amp;&amp; !isBuff &amp;&amp; isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length; for (var key in value) &#123; if ((inherited || hasOwnProperty$1.call(value, key)) &amp;&amp; !(skipIndexes &amp;&amp; ( // Safari 9 has enumerable `arguments.length` in strict mode. key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers. (isBuff &amp;&amp; (key == 'offset' || key == 'parent')) || // PhantomJS 2 has enumerable non-index properties on typed arrays. (isType &amp;&amp; (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) || // Skip index properties. isIndex(key, length) ))) &#123; result.push(key); &#125; &#125; return result;&#125;function baseKeys(object) &#123; if (!isPrototype(object)) &#123; return nativeKeys(object); &#125; var result = []; for (var key in Object(object)) &#123; if (hasOwnProperty$3.call(object, key) &amp;&amp; key != 'constructor') &#123; result.push(key); &#125; &#125; return result;&#125; keys方法会使用 isArrayLike 方法先判断当前对象是否是类似数组的对象，即判断 该对象不是函数，该判断有些复杂，还考虑了浏览器兼容问题 该对象拥有value.length属性，并且该值是一个大于-1且小于MAX_SAFE_INTEGER的整数 注意这里必须是整数，这里有一个巧妙的设计，即： value % 1== 0。可以拿一个小数 2.4 验证一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Checks if `value` is array-like. A value is considered array-like if it's * not a function and has a `value.length` that's an integer greater than or * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`. * * @static * @memberOf _ * @since 4.0.0 * @category Lang * @param &#123;*&#125; value The value to check. * @returns &#123;boolean&#125; Returns `true` if `value` is array-like, else `false`. * @example * * _.isArrayLike([1, 2, 3]); * // =&gt; true * * _.isArrayLike(document.body.children); * // =&gt; true * * _.isArrayLike('abc'); * // =&gt; true * * _.isArrayLike(_.noop); * // =&gt; false */function isArrayLike(value) &#123; return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);&#125;function isLength(value) &#123; return typeof value == 'number' &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER;&#125;/** `Object#toString` result references. */var asyncTag = '[object AsyncFunction]';var funcTag = '[object Function]';var genTag = '[object GeneratorFunction]';var proxyTag = '[object Proxy]';function isFunction(value) &#123; if (!isObject(value)) &#123; return false; &#125; // The use of `Object#toString` avoids issues with the `typeof` operator // in Safari 9 which returns 'object' for typed arrays and other constructors. var tag = baseGetTag(value); return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;&#125;function isObject(value) &#123; var type = typeof value; return value != null &amp;&amp; (type == 'object' || type == 'function');&#125; 本来想弄一个测试案例来试试 arrayLikeKeys 方法，但是不太好举例，因为在 iterator 方法中已经做了一次 isArrayLike 的判断，所以按照给方法进去的话应该就不会在走 arrayLikeKeys 方法。arrayLikeKeys 这块的实现有时间可以研究下，这里就做了其他的案例测试。&emsp;&emsp;将我传入的参数改为如下 obj 对象，执行会报错，因为有两个属性不是函数。所以执行的时候会出错 series实现暂且分析到这里，通过源码分析可以发现一些有趣的实现，比如如何确保函数只会执行一次，有两个方法实现一个是once，一个是onlyOnce， 一目了然。他们都是使用了高阶函数，然后将函数复制一份后赋值 null ：1234567891011121314151617function once(fn) &#123; return function () &#123; if (fn === null) return; var callFn = fn; fn = null; callFn.apply(this, arguments); &#125;;&#125;function onlyOnce(fn) &#123; return function() &#123; if (fn === null) throw new Error("Callback was already called."); var callFn = fn; fn = null; callFn.apply(this, arguments); &#125;;&#125;]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将Ado.net中的事务抽离到业务层]]></title>
    <url>%2FC%2FAop%2Fado-net-declarative-tx%2F</url>
    <content type="text"><![CDATA[&emsp; &emsp;最近在实现一个简单的审批功能，涉及到一些事务的处理。一个管控台项目，我使用的是最简单的三层架构。使用的是Ado.net操作数据库。先看一段我们经常用到的事务代码：123456789101112131415SqlConnection con = new Sqlconnection("数据库连接语句");con.Open();var trans = con.BeginTransaction();try&#123; SqlCommand com = new SqlCommand(trans); //处理插入或更新逻辑 trans.Commit();&#125;catch(ex)&#123; trans.Rollback();//如果前面有异常则事务回滚&#125;finally&#123; con.Close();&#125; &emsp; &emsp;我一直以来都是使用下面这种方式在Dao来处理事务，其实怎么看都觉得他别扭，就拿我做的审批功能来说，当前审批人通过之后需要生成一条审批记录（记作表ApprovalHistory），同时将当前申请单的当前审批人指向下一个处理者(记作Apply)，而一般的三层架构都会有自身的Service层，理想的情况应该是在Service层用事务来处理相应的逻辑。 正常的处理逻辑应该是将事务提取出来，应用层不应该过多的去关心底层的实现。乱糟糟的代码写在一起分层感觉也没啥意思了。如果可以像Spring那样使用Annotation的方式就一行代码来实现事务这样不是很好吗。这个问题确实想了挺久，后来有位boss和我说了下他的实现，喜出望外！先贴贴代码实现 Boss的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360 public class ConnId &#123; private int mConnId = 0; private DateTime mCreateTime = DateTime.Now; public int MConnId &#123; get &#123; return this.mConnId; &#125; &#125; public ConnId(int connid) &#123; this.mConnId = connid; &#125; &#125; public class DbConnection&#123; private static readonly string sConnStr = "从配置中读取连接字符串"; public static readonly long MAX_LAST_TIME_LEN = 10 * 1000 * 1000 * 60; private ConnId mConnId = null; private SqlConnection mConn = null; private SqlCommand mSqlCmd= null; private DateTime mCreateTime = DateTime.Now; private string mTransName = ""; public ConnId MConnId &#123; get &#123; return this.mConnId; &#125; &#125; public SqlConnection Connection &#123; get &#123; return this.mConn; &#125; &#125; public SqlCommand SqlCmd &#123; get &#123; return this.mSqlCmd; &#125; &#125; public ConnectionState State &#123; get &#123; if (mConn == null) &#123; return ConnectionState.Broken; &#125; else &#123; return mConn.State; &#125; &#125; &#125; public DbConnection() &#123; &#125; internal ConnId ConnOpen(HttpRequest request) &#123; try &#123; this.mConn = new SqlConnection(sConnStr); this.mSqlCmd = new SqlCommand(); mSqlCmd.Connection = this.mConn; this.mConnId = new ConnId(this.GetHashCode()); mConn.Open(); if (request == null) &#123; mTransName = "null"; &#125; else &#123; mTransName = GetSrcFileName(request); &#125; mSqlCmd.Transaction = mConn.BeginTransaction(System.Data.IsolationLevel.ReadCommitted, mTransName); //log &#125; catch (Exception e) &#123; //log if (this.mConn.State != System.Data.ConnectionState.Closed) &#123; this.mConn.Close(); this.mConn.Dispose(); &#125; this.mConnId = null; &#125; return this.mConnId; &#125; internal ConnId ConnOpen(string src) &#123; try &#123; this.mConn = new SqlConnection(sConnStr); this.mSqlCmd = new SqlCommand(); mSqlCmd.Connection = this.mConn; this.mConnId = new ConnId(this.GetHashCode()); mConn.Open(); mTransName = src; mSqlCmd.Transaction = mConn.BeginTransaction(System.Data.IsolationLevel.ReadCommitted, mTransName); //log &#125; catch (Exception e) &#123; //log if (this.mConn.State != System.Data.ConnectionState.Closed) &#123; this.mConn.Close(); this.mConn.Dispose(); &#125; this.mConnId = null; &#125; return this.mConnId; &#125; internal Exception Cancel() &#123; Exception ex = null; try &#123; //log mSqlCmd.Transaction.Rollback(); &#125; catch (Exception e) &#123; //log mSqlCmd.Transaction.Rollback(); ex = e; &#125; finally &#123; if (mSqlCmd != null) &#123; this.mSqlCmd.Dispose(); &#125; if (this.mConn.State != System.Data.ConnectionState.Closed) &#123; this.mConn.Close(); &#125; memberClear(); &#125; return ex; &#125; internal Exception Close() &#123; Exception ex = null; try &#123; //log mSqlCmd.Transaction.Commit(); &#125; catch (Exception e) &#123; //log mSqlCmd.Transaction.Rollback(); ex = e; &#125; finally &#123; if (mSqlCmd != null) &#123; this.mSqlCmd.Dispose(); &#125; if (this.mConn.State != System.Data.ConnectionState.Closed) &#123; this.mConn.Close(); this.mConn.Dispose(); &#125; memberClear(); &#125; return ex; &#125; internal bool IfExpried() &#123; if (mConnId != null) &#123; if (mCreateTime != DateTime.MinValue) &#123; DateTime now = DateTime.Now; if (now.Ticks - this.mCreateTime.Ticks &gt; MAX_LAST_TIME_LEN) &#123; return true; &#125; &#125; &#125; return false; &#125; private void memberClear() &#123; mConnId = null; mConn = null; mSqlCmd= null; mCreateTime = DateTime.MinValue; &#125; private string GetSrcFileName(HttpRequest r) &#123; FileInfo fi = new FileInfo(r.PhysicalPath); string filename = fi.Name.Replace(fi.Extension, ""); if (filename.Length &gt; 32) &#123; filename = filename.Substring(filename.Length - 32, 32); &#125; return filename; &#125; private string GetSrcFileName(string src) &#123; return src.Substring(src.Length - 32, 32); &#125; private string GetShortTime(DateTime t) &#123; string str = t.Day.ToString() + "_" + t.Hour.ToString() + ":" + t.Minute.ToString() + ":" + t.Second.ToString(); return str; &#125;&#125; public class ConnPool&#123; private static readonly object sLocker = new object(); private static Dictionary&lt;ConnId, DbConnection&gt; sConnList = new Dictionary&lt;ConnId, DbConnection&gt;(MAX_CONCURRENT_CONN_COUNT); private static readonly int MAX_CONCURRENT_CONN_COUNT = 1000; public static int sCount &#123; get &#123; return sConnList.Keys.Count; &#125; &#125; public static ConnId CreateConn(HttpRequest request) &#123; DbConnection dbconn = null; ConnId key = null; try &#123; dbconn = new DbConnection(); key = dbconn.ConnOpen(request); if (sConnList.ContainsKey(key)) &#123; return key; &#125; if (sCount &lt; MAX_CONCURRENT_CONN_COUNT) &#123; lock (sLocker) &#123; if (sCount &lt; MAX_CONCURRENT_CONN_COUNT) &#123; sConnList.Add(key, dbconn); &#125; else &#123; //log &#125; &#125; &#125; &#125; catch (Exception e) &#123; //log key = null; &#125; return key; &#125; public static ConnId CreateConn(string src) &#123; DbConnection dbconn = null; ConnId key = null; try &#123; dbconn = new DbConnection(); key = dbconn.ConnOpen(src); if (sCount &lt; MAX_CONCURRENT_CONN_COUNT) &#123; lock (sLocker) &#123; if (sCount &lt; MAX_CONCURRENT_CONN_COUNT) &#123; sConnList.Add(key, dbconn); &#125; else &#123; //log &#125; &#125; &#125; &#125; catch (Exception e) &#123; //log key = null; &#125; return key; &#125; public static int ReleaseConn(ConnId connid) &#123; DbConnection conn = null; try &#123; lock (sLocker) &#123; conn = sConnList[connid]; sConnList.Remove(connid); &#125; if (conn != null) &#123; conn.Close(); &#125; &#125; catch (Exception e) &#123; //log &#125; return 0; &#125; public static int CancelConn(ConnId connid) &#123; DbConnection conn = null; try &#123; lock (sLocker) &#123; conn = sConnList[connid]; sConnList.Remove(connid); &#125; if (conn != null) &#123; conn.Cancel(); &#125; &#125; catch (Exception e) &#123; //log &#125; return 0; &#125; public static DbConnection GetDbConn(ConnId connid) &#123; return sConnList[connid]; &#125;&#125; 然后使用的时候呢就像这样就可以：1234567891011121314151617181920212223namespace MyTest&#123; class Program &#123; static void Main(string[] args) &#123; ConnId conn = ConnPool.CreateConn("123"); try &#123; var aservice = new ApplyService(); var historyService = new ApprovalHistoryService(); aservice.Update(new object(), conn); historyService.Insert(new object(), conn); ConnPool.ReleaseConn(conn); &#125; catch (Exception ex) &#123; ConnPool.CancelConn(conn); &#125; &#125; &#125;&#125; &emsp; &emsp;可以看到这里主要是在ConnPool中使用一个Dictionary加双重检查锁定来实现一个并发连接的处理，用于记录当前的数据库连接。而到执行Insert和Update时他就通过connid在ConnPool中取出对应事务中的SqlCommand来执行相应的Sql 。也就是说他将数据库连接及事务抽离，放到了一个ConnPool中管理。基本符合我预期。 问题来了 &emsp; &emsp;如果认真看着里面的实现大家应该会发现这里存在一些问题。 1 并发字典的实现 &emsp; &emsp;头一个我想到的就是双重检查锁定的问题，虽然老总说他们用了那么久一直没有什么问题，但我想说那是因为并发量不大所以没有发现问题，并发量大的情况下使用lock的性能是明显下降的，这就让我想起了Java中从HashMap 到 HashTable 再到 ConcurrentHashMap的转变。HashMap是非线程安全类，所以用在多线程环境下就很可能出现意想不到的结果。所以才有了HashTable，我印象当中HashTale的实现是在HashMap的基础上为每个方法加了synchronized关键字，所以每次Add或Remove都会锁住整个内部的数组，可以想象一下在多线程环境下这里面的操作会有多慢。所以才有了ConcurrentHashMap的实现，其内部使用的是可重入锁，而锁住的是每一个segment段而不是整个数组。更重要的是锁的实现（基础框架是队列同步器AbstractQueuedSynchronizer），追究到最底层实现是使用CAS加自旋，一种乐观锁的方式来实现，从而保证了并发性。从HashMap 到 HashTable 再到 ConcurrentHashMap的转变真让我回味良久，从里面数据结构的设计到并发的处理真是妙不可言。学习Java的朋友应该知道这可以从放腾飞中的《并发编程的艺术》中了解到，初学者看可能会晕，我第一次看了一小部分后是拒绝的，因为看得想吐，心里在咒骂这他妈都写的什么鬼，哈哈！再后来慢慢看就有所体会了，而且有些地方还要反复琢磨。从这本书可以了解到很多并发编程的底层实现，极力推荐！！！ &emsp;&emsp;所以我也并不推荐自己去实现一个线程安全的Dictionary，因为里边涉及到太多的细节不是我们所能预料的，除非自己真的非常熟悉底层的实现，对并发编程了然于胸。看过.Net中的 Dictionary实现后会发现它与HashMap的实现大体无异，虽然没有看过.Net中ConcurrentDictionary的实现，但是个人感觉他们的实现大体上应该相差无几。所以可以考虑使用ConcurrentDictionary来替换老总ConnPool的内部实现，这部分代码就不贴了。 2 非托管资源的释放 &emsp; &emsp;对于非托管资源的释放我建议是使用继承接口IDisposable来实现其Dispose()方法，具体请参考.Net圣经 -《CLR via C# 第4版 》。 &emsp; &emsp; ####改进&emsp;&emsp; 虽然老总的实现能抽离的底层的实现，但是还不够优雅，因为在代码的最后都要去手动实现事务的提交和回滚。那有没有更好的办法来实现不用手动提交和回滚呢，就像Spring中事务，只需要在方法中加注解就可以达到指定功能。当然初期先来一个简单的实现。.Net中的Attribute对应的就是Java中的注解，但是这个Attribute还必须具备Aop的功能。这样才可以在方法执行前开启一个事务，方法执行完成后提交或回滚事务。 1. Aop&emsp;&emsp; 一般使用的较多的是Autofac和Castle，当然还可以使用Remoting代理方式或者从ContextBoundObject中派生来实现。刚好找到一篇文章说到了.net实现Aop的七种方式。 Approach Advantages Disadvantages Remoting Proxies Easy to implement, because of the .Net framework support Somewhat heavyweight Can only be used on interfaces or MarshalByRefObjects Derivingfrom ContextBoundObject Easiest to implement Native support for call interception Very costly in terms of performance Compile-time subclassing ( Rhino Proxy ) Easiest to understand Interfaces or virtual methods only Runtime subclassing ( Castle Dynamic Proxy ) Easiest to understand Very flexible Complex implementation (but alreadyexists) Interfaces or virtual methods only Hooking into the profiler API ( Type Mock ) Extremely powerful Performance? Complex implementation (COM API, require separate runner, etc) Compile time IL-weaving ( Post Sharp / Cecil ) Very powerful Good performance Very hard to implement Runtime IL-weaving ( Post Sharp / Cecil ) Very powerful Good performance Very hard to implement 当然这只是前人做的一个总结，具体的性能及优缺点还需要自己去考量。编译时AOP工具有：PostSharp、LinFu、SheepAspect、Fody、CIL操作工具。运行时AOP工具：Castle Windsor/DynamicProxy、StructureMap、Unity、Spring.NET。&emsp;&emsp; 我用得比较多的是运行时Aop，比如Castle、Autofac.他们都是使用动态代理的方式来实现。来看看Castle是怎么实现的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 using Castle.DynamicProxy; using System; class Program&#123; static void Main(string[] args) &#123; ProxyGenerator generator = new ProxyGenerator(); SimpleInterceptor interceptor = new SimpleInterceptor(); Person person = generator.CreateClassProxy&lt;Person&gt;(interceptor); person.SayHello(); Console.Read(); &#125;&#125; public class Person&#123; public virtual void SayHello() &#123; Console.WriteLine("hello world."); &#125; public virtual void SayName(string hometown) &#123; Console.WriteLine("I'm Lynch, I'm from &#123;0&#125;.", hometown); &#125; public void SayOther() &#123; Console.WriteLine("Yeah, I'm Chinese."); &#125;&#125; public class SimpleInterceptor : StandardInterceptor&#123; protected override void PreProceed(IInvocation invocation) &#123; Console.WriteLine("before invocation , method : &#123;0&#125;.", invocation.Method.Name); base.PreProceed(invocation); &#125; protected override void PerformProceed(IInvocation invocation) &#123; Console.WriteLine("before performing ..."); base.PerformProceed(invocation); Console.WriteLine("after performing..."); &#125; protected override void PostProceed(IInvocation invocation) &#123; Console.WriteLine("after invacation , method : &#123;0&#125;.", invocation.Method.Name); base.PostProceed(invocation); &#125;&#125; 动态代理的方式有个不好的地方就是每次都要生成指定类型的代理类，要实现Aop的方法还必须是virtual方法. 如果有很多类很多方法需要拦截那增加和改动的代码就有点多。我想达到的目标是只要一个Attribute类，不需要生成指定类型的代理类，让代码看起来更加的干净。一直以来我只知道有运行时Aop，就没有想到编译时Aop，比如postsharp。然后就找到了Mono.Cecil ，通过改写中间IL代码的方式来实现，大体思路是 找到标记有指定AopAttribute的方法 复制该方法并生成一个新的方法copy_method，复制完成后清楚原有方法 改写原有方法，首先调用AopAttribute的OnStart方法，接着调用copy_method ，调用AopAttribute的OnSuccess方法，最后调用AopAttribute的OnEnd方法 postsharp 1.5 使用注意事项，.net Framework 必须是3.5版本，需要在csproj中增加以下内容1234567 &lt;PropertyGroup&gt; &lt;PostSharpUseCommandLine&gt;True&lt;/PostSharpUseCommandLine&gt; &lt;DontImportPostSharp&gt;True&lt;/DontImportPostSharp&gt; &lt;PostSharpDirectory&gt;libs&lt;/PostSharpDirectory&gt; &lt;/PropertyGroup&gt; &lt;Import Project=&quot;$(PostSharpDirectory)\PostSharp-1.5.targets&quot; /&gt; 2. IL &emsp;&emsp;说到IL指令就要先知道什么是evaluation stack。而这个evaluation stack却不同于我们平时理解的Call Stack（调用栈），即在调用一个方法时首先会将所有参数压栈，压栈完成后调用指定方法，方法执行完成清理刚刚入栈的参数。我写这个IL指令的时候我也纳闷了，我就在想我大学的时候用Intel x86汇编自己实现小型操作系统的时候也没有遇到这个东西啊，说到栈就Call Stack，这evaluation stack（以下简称EStack）他妈是什么鬼。后来向朋友了解了一下才知道这个是CIL特有的东西，这个是个寄存器，即Stack&lt; Register &gt; 。这样就说通了，我忘了操作结果的存放，学过汇编或了解一些底层的同学应该了解，汇编语言的操作结果都是存放的寄存器中，如32位的ax , bx，64位 eax、ebx等通用寄存器。而不同的CPU又有不同的指令集，如PC机使用的是x86复杂指令集，而Arm使用的是Arm的精简指令集，而CLR直接将兼容不同的寄存器的工作交给使用者处理的话那使用者势必想疯掉，所以VM做一个通用的寄存器来存放操作结果，至于该使用哪个寄存器来存放使用者不需要关心。 &emsp;&emsp;至于为什么设计成栈的结构，个人理解一个是栈有内存限制，我们一般使用到的临时变量局部变量或者方法参数都不会太多，当然也可能很多，太多参数的话就该考虑封装了。二个我觉得更重要的是它非常符合调用方法前将参数出入Call Stack的操作，例如我们来执行一下伪代码： 1234int a = 123;Service service = new Service(&quot;lynch&quot;);var b = service.GetNumber();var result = service.Add(a,b); 在执行Add方法前会先调用GetNumber来获取b的值，整个代码的执行指令是 12IL_0001: ldc.i4.s 123 将123赋值给寄存器即放到EStack中 IL_0003: stloc.0 将EStack中索引为0的值出栈，并将出栈的值push到Call Stack作为Add方法的入参 限于篇幅剩下的IL代码就不贴了，从第二行的st前缀指令大家应该可以发现 : 这个指令包含了两个操作，一个从EStack出栈，二个将出栈的值入栈Call Stack。EStack是通过ld入栈而st出栈，就是说使用到某个参数的时候就将其从EStack出栈，而无需再占用栈空间，也就释放了栈内存，是不是有点像Call Stack的操作。个人一些见解，不足之处还望指正。 &emsp;&emsp;在IL指令中我们会频繁用到如ld ( load )、st(store)等前缀指令，ld前缀指令的意思就是将寄存器的值压栈，也就是将EStack中的值push到Call Stack，而st前缀指令就是将Call Stack中的操作结果存放到寄存器EStack中。大家可以通过这篇文章做个基本了解 Understanding Common Intermediate Language (CIL) 如果想深入了解的可以看《Inside Microsoft .NET IL Assembler》，中文版是《Microsoft.NET IL汇编语言程序设计》，不过中文版已经绝版，网上可以找到很多影印版pdf。 3. Aop的实现&emsp;&emsp;这个应该算是postsharp的简单实现，源码放在了Github LeoxAop上。代码我就不贴了，很多地方都有注释，而且逻辑还算清晰。这里的实现部分参考了MSBuild + MSILInect实现编译时AOP之预览这位博主的实现，不过他写的应该过于匆忙，所以代码结构有些凌乱，不太容易看懂，还用了很多的linq。&emsp;&emsp;这里有一个待解决的问题是将代码注入到指定项目exe或dll后怎么让VS调试到指定的AopAttribute代码，也就是说怎么生成对应的pdb文件让VS感知到。就像.net reflector 一样，反编译dll后自动生成对应的pdb文件，然后就可以顺利的调试。我目前想到的较为简单的方法是在开发者命令中使用ildasm 将文件反编译为il代码，然后再使用ilasm生成对应的pdb文件 :12ildasm test.exe /out=test.ililasm test.il /pdb 不过我试过发现并没有起作用，哪位朋友知道的麻烦告诉我一下，万分感激。就因为这个也花了不少时间，搜google搜codeproject都没有找到相关的文章，实在没办法先搁放在这里，太过纠结容易崩溃。本以为很快能结篇，还不料涉及的东西有点多，写代码调试解决遇到的bug也花不少时间。这里是.net 的实现，其实java也可以这么实现，只是要了解java的字节码，有时间再写吧。 扩展阅读 栈式虚拟机和寄存器式虚拟机？4. Transaction 实现&emsp;&emsp;终于写到了这了，迫不及待啊。感叹时间飞快。写完这个接下来我想看的东西就是node里边Promise和Async的实现。既然Aop功能已经实现，那我们就可以在OnStart方法开始一个事务，在OnSuccess和OnException提交或回滚事务，但是这里还有几个问题需要考虑： 就是如果使用者的在自身业务代码就已经做了异常捕获该如何处理，是该回滚还是该提交，这个还没想出来好的解决办法。 如果有部分连接未能及时释放又该如何处理，对于这个问题可以考虑启动一个线程来监控，根据连接开始创建的时间来做判断。 底层dao操作需要用到当前连接创建的SqlCommand，要获取到这个那就需要记录连接Id，问题是这个Id只有在相应Aop的On事件时才能拿到。还有没有其他办法呢，因为每个线程执行时用的连接Id都不一样所以我想到一个办法就是将这个变量放到ThreadLocal中，线程跑到哪里它就跟到哪，每个线程都维持着自己的连接Id。如果这个问题不解决那设计这一整个抽象事务就没用了。可能应该还有更好的办法，还没来得及去看Spring中实现，如果有朋友想到更好的办法麻烦告诉我一声，感激不尽！ 连接Id如何保证唯一性。当前我使用的是guid生成，只是一个临时的策略。考虑到分布式架构的话这种生成方式就不太好管理，也不稳妥。我比较喜欢 Twitter 分布式自增Id的实现snowflake，说喜欢是因为它的实现粒度很细，但是没有考虑到它强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。当然也可以参考MongoDb中ObjectId 的生成方式。后来有幸看到朋友转发的一篇文章，里面有说到唯一Id的多种生成方式，还介绍了snowflake及ObjectId的优缺点，最后讲到一种新的生成算法Leaf，大家可以了解下Leaf——来自美团点评的分布式ID生成系统&emsp;&emsp;当然如果是分布式架构那没这么简单了，需要考虑分布式事务，涉及两阶段三阶段提交、分布式一致性算法 paxos。不过现在更多的应该考虑放弃强一致性的分布式事务而使用最终一致性。如eBay的实现，在设计上就不采用分布式事务，而是通过其它途径来解决数据一致性问题。其中使用的最重要的技术就是消息队列和消息应用状态表。至于阿里和京东怎么实现就没有深入了解过。eBay 实现参考 : Base: An Acid Alternative 最后 Transaction 的实现请参见 Leox.Transaction]]></content>
      <categories>
        <category>C#</category>
        <category>Aop</category>
      </categories>
      <tags>
        <tag>Aop</tag>
        <tag>IL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript Lambda的简单实现]]></title>
    <url>%2Fjavascript%2Flambda%2Fjs-lambda%2F</url>
    <content type="text"><![CDATA[由来 今早面试看到一题是说使用js实现.net中的where功能，当时脑子里一片空白，只能回来脑补下（本来想将博客放到github及Blogger上，但限于配置麻烦，暂且放这里）。真心不知道ES6以下的js支不支持 “ =&gt; “， 后来在chrome上测试下竟然支持，我没有打开chrome对ES6的支持。这是一个简单实现，主要使用到了eval，暂时没有考虑其性能，同时实现了 select 及distinct方法，欢迎大牛指正。既然语法支持那就可以对传入的参数做进一步处理，首先将参数转为字符串然后使用正则提取变量及表达式，到使用eval执行语句时再将表达式中的参数替换为指定的值。以下代码还可以重构，可以考虑写一个方法专门解析表达式、增加表达式正确性校验等等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 Array.prototype.where = function()&#123; var args = arguments[0].toString(); var matches = args.match(/(\w)(\s+)?=&gt;(.*)+/); if(!matches)&#123; console.error('invalid expression.'); return; &#125; var name = matches[1]; var expression = matches[3]; if(!this) return []; var result=[]; this.forEach(function(value, index, array) &#123; eval('var rpr=/'+ name + '/g'); var newexp = expression.replace(rpr,value); var res = eval(newexp); if(res)&#123; result.push(value); &#125;&#125;);return result; &#125;; Array.prototype.select = function()&#123; var args = arguments[0].toString(); var matches = args.match(/(\w)(\s+)?=&gt;(.*)+/); if(!matches)&#123; console.error('invalid expression .'); return; &#125; var name = matches[1]; var expression = matches[3]; matches = expression.match(/\.(\w+)/); if(!matches) &#123; console.error('invalid expression .'); return; &#125; var property = matches[1]; var result=[]; this.forEach(function(value, index, array) &#123; if(value[property])&#123; result.push(value[property]); &#125;&#125;);return result; &#125;; Array.prototype.distinct = function()&#123; var args = arguments[0].toString(); var matches = args.match(/(\w)(\s+)?=&gt;(.*)+/); if(!matches)&#123; console.error('invalid expression .'); return; &#125; var name = matches[1]; var expression = matches[3]; matches = expression.match(/\.(\w+)/); if(!matches) &#123; console.error('invalid expression .'); return; &#125; var property = matches[1]; var result=[]; this.forEach(function(value, index, array) &#123; if(value[property])&#123; var add = true; for (var i = 0; i &lt; result.length; i++) &#123; if(value[property]==result[i][property])&#123; add = false; break; &#125; &#125; if(add) result.push(value); &#125;&#125;);return result; &#125;; var mres = [20,33,40,89,55].where(x=&gt;x%5==0); var seles = [&#123;age:423&#125;,&#123;age:120&#125;,&#123;name:'leo',age:80&#125;].select(a=&gt;a.age); var distic = [&#123;age:423&#125;,&#123;age:120&#125;,&#123;age:120&#125;, &#123;name:'leo',age:80&#125;,&#123;name:'leo',age:80&#125;].distinct(a=&gt;a.age); console.log(mres); 结果 ###性能测试 昨天看一个篇不错的文章里面使用了10万数据来测试eval及function，看到这个那我也来试试。代码修改如下：123456789101112131415var arrs = [],models=[];for (var i = 0; i &lt; 100000; i++) &#123; arrs.push(i); models.push(&#123;age:i,name:'name'+i&#125;);&#125;console.time("where");var mres = arrs.where(x=&gt;x%5==0);console.timeEnd("where");console.time("select");var seles = models.select(a=&gt;a.age);console.timeEnd("select");console.time("distinct");var distic = models.distinct(a=&gt;a.age);console.timeEnd("distinct"); 相比distinct，其他两个 很快就能看到结果，过了7-8分钟还是没有结果，后来看了下代码，自己真是笑死。distinct使用了一个最坏的情况来运行，arrs中没有重复数据，时间复杂度是O(n2)，这么看没有个把钟出不来. 那就先让他自己运行吧，刚好和妹子有约，晚上回来在看。晚上11点半到家，结果如下： 结果和预期差不多，一个半小时，chrome按F12在debug模式下会慢些。既然如此那就来调整下，一个是where的实现，一个distinct的是实现，select功能少暂时可以不用考虑。 ###where先看使用eval的实现：然后是function的实现： 最后看结果： 从结果看这差距不是一般的大。 ###distinct这个然我想起了之前看到的位图算法，用一个bit位来记录某项记录是否已存在，我们可以使用的最小数据类型只能是float及int，可以考虑使用强类型数组 Uint32Array。这里有个问题是我们事先并不能知道某一个数的大小，有可能该数据所在的位置已经超出bit_arr的界限，所以这个需要做判断。如果超出则增加bit_arr的长度。然后我的实现如下： 12345678910111213141516171819202122232425262728293031(function()&#123; var bit_arr ; var get = function(index,offset)&#123; var value = bit_arr[index]&gt;&gt;offset; return value &amp; 0x01; &#125;; var set = function(index,offset)&#123; bit_arr[index] = bit_arr[index]+(1&lt;&lt;offset); &#125; window.distinct = function(arr)&#123; var count = parseInt(arr.length/32) + 1; bit_arr = new Uint32Array(count); for (var i = 0; i &lt; count; i++) &#123; bit_arr[i]=0; &#125; var results = []; arr.forEach(function(value,index,array)&#123; var arr_index = parseInt(value/32); var offset = value%32; if(!bit_arr[arr_index]) bit_arr[arr_index] = 0; var bit = get(arr_index,offset); if(bit == 0)&#123; set(arr_index,offset); results.push(value); &#125; &#125;); return results; &#125;; &#125;)(); 测试代码如下：1234567891011121314151617var arrs = [],models=[];for (var i = 0; i &lt; 20000; i++) &#123; arrs.push(i); // models.push(&#123;age:i,name:'name'+i&#125;);&#125;for (var i = 0; i &lt; 20000; i++) &#123; arrs.push(i);&#125;for (var i = 0; i &lt; 40000; i++) &#123; arrs.push(i*2);&#125;for (var i = 0; i &lt; 20000; i++) &#123; arrs.push(i*3);&#125;console.time("distinct");distinct(arrs);console.timeEnd("distinct"); 测试结果： 结果还明显，我多次测试其时间都在130ms左右。 ###总结 其实很多时候只要有一个点子一个想法都可以去尝试，做出来后定会有收获。有关lambda部分还有很多功能可以实现，像前面提到的那位博主有考虑到缓存function，不过他的lambda表达式是使用字符串包含的，感觉不太雅观。CSDN的编辑器太操蛋，竟然没有自动保存草稿的功能，害我重写，哎…真不够专业。还是马克飞象好些。先这样了，后续有想法再补充。 个人github博客地址参见 http://blog.magicleox.com/ 有关eval性能的文章：http://www.nowamagic.net/librarys/veda/detail/1627 https://www.nczonline.net/blog/2013/06/25/eval-isnt-evil-just-misunderstood/]]></content>
      <categories>
        <category>javascript</category>
        <category>lambda</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
</search>
